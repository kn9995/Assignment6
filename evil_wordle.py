"""
Student information for this assignment:

Replace Karen Ngu with your name.
On my/our honor, <FULL NAME> and <FULL NAME>, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: KN9995
UT EID 2:
"""

import random
import sys

# ANSI escape codes for text color
# These must be used by wrapping it around a single character string
# for the test cases to work. Please use the color_word function to format
# the feedback properly.

CORRECT_COLOR = "\033[3;1;102m"
WRONG_SPOT_COLOR = "\033[3;1;90;103m"
NOT_IN_WORD_COLOR = "\033[3;1m"
NO_COLOR = "\033[0m"

# Used for the explanation.
BOLD_COLOR = "\033[1m"

# If you are colorblind for yellow and green, please use these colors instead.
# Uncomment the two lines below. Commenting in and out can be done by
# highlighting the  lines you care about and using:
# on a windows/linux laptop: ctrl + /
# on a mac laptop: cmd + /

# CORRECT_COLOR = "\033[3;1;97;101m"
# WRONG_SPOT_COLOR = "\033[3;1;97;104m"

# The total number of letters allowed
NUM_LETTERS = 5

INVALID_INPUT = "Bad input detected. Please try again."


class Keyboard:
    """
    The Keyboard class displays and updates a text-based keyboard that prints 
    after every guess. The colors of the keyboard letters are updated per guess 
    to reflect which guessed letters are correctly placed, incorrectly placed, 
    or not present in the secret word. 

    Instance Variables:
        rows: A tuple of strings, each representing a row of letters on the keyboard.
        colors: A dictionary mapping each letter to its current feedback color.
    """

    def __init__(self):
        """
        Initializes the Keyboard object by setting up the rows of keys and initializing
        each key with a default 'NO_COLOR' state.
        """
        self.rows = ("qwertyuiop", "asdfghjkl", "zxcvbnm")
        self.colors = {letter: NO_COLOR for letter in "qwertyuiopasdfghjklzxcvbnm"}

    def update(self, feedback_colors, guessed_word):
        """
        Updates the color of each letter on the keyboard based on feedback from a guessed word.

        If a letter's feedback color is `CORRECT_COLOR`, the letter on the keyboard 
        is updated. If the color is `WRONG_SPOT_COLOR`, the color updates only 
        if the keyboard's current color for that letter is not `CORRECT_COLOR`. 
        Letters marked with `NO_COLOR` retain that color unless any feedback 
        changes it.

        pre:
            feedback_colors: A tuple of color ANSI escape codes indicating 
            feedback for each letter. len(feedback_colors) == len(guessed_word). 
            Each item in feedback_colors must be a valid color constant.
            guessed_word:  A list of string characters; the word guessed by the user.

        post: None
        """
        for i, letter in enumerate(guessed_word):
            color = feedback_colors[i]
            if color == CORRECT_COLOR:
                self.colors[letter] = CORRECT_COLOR
            elif color == WRONG_SPOT_COLOR:
                if self.colors[letter] != CORRECT_COLOR:
                    self.colors[letter] = WRONG_SPOT_COLOR
            elif color == NOT_IN_WORD_COLOR:
                if self.colors[letter] == NO_COLOR:
                    self.colors[letter] = NOT_IN_WORD_COLOR

    def __str__(self):
        """
        Returns a string representation of the keyboard, showing each letter in its
        corresponding color. Each row of the keyboard is formatted for readability,
        with spacing adjusted for alignment. Color each individual letter using color_word()
        based on the colors in the dictionary.

        The first row has no leading spaces.
        The second keyboard row has 1 leading space.
        The third keyboard row has 3 leading spaces.

        pre: None
        post: Returns a formatted string with each letter colored according to feedback
              and arranged to match a typical keyboard layout.
        """
        row1 = " ".join([color_word(self.colors[letter], letter) for letter in self.rows[0]])
        row2 = " ".join([color_word(self.colors[letter], letter) for letter in self.rows[1]])
        row3 = " ".join([color_word(self.colors[letter], letter) for letter in self.rows[2]])
        return f"{row1}\n {row2}\n   {row3}"


class WordFamily:
    """
    A class representing a group or 'family' of words that match a specific 
    pattern of feedback_colors. Each word family has a difficulty level determined 
    by the total feedback_color difficulty and the number of words in the family.

    Class Variables:
        COLOR_DIFFICULTY: A dictionary mapping color codes to numeric difficulty levels.

    Instance Variables:
        feedback_colors: A tuple representing feedback colors for a guessed word.
        words: A list of words that match the feedback pattern.
        difficulty: An integer representing the cumulative difficulty of this word family.
    """

    COLOR_DIFFICULTY = {CORRECT_COLOR: 0, WRONG_SPOT_COLOR: 1, NOT_IN_WORD_COLOR: 2}

    def __init__(self, feedback_colors, words):
        """
        Initializes the WordFamily based on the feedback colors list. The 
        difficulty of the family is calculated based on the color difficulty of 
        each character in the feedback colors.

        pre:
            feedback_colors: A tuple representing feedback colors for a guessed word.
            words: A list of words that match the feedback pattern.
        post: None
        """
        self.feedback_colors = feedback_colors
        self.words = words
        self.difficulty = 0
        for color in feedback_colors:
            self.difficulty += WordFamily.COLOR_DIFFICULTY[color]

    def __lt__(self, other):
        """
        Compares this WordFamily object with another by prioritizing a larger
        number of words, higher difficulty, and lexicographical order of the feedback_color.
        Raises an error if other is not a WordFamily object.

        pre: `other` is a WordFamily object.
        post: 
            True if this instance is 'less than' the other, False otherwise. 
            Raises NotImplementedError with the message: "< operator only valid 
            for WordFamily comparisons." if `other` is not a WordFamily instance.
        """
        if not isinstance(other, WordFamily):
            raise NotImplementedError("< operator only valid for WordFamily comparisons.")
        return ((-len(self.words), -self.difficulty, self.feedback_colors) <
                (-len(other.words), -other.difficulty, other.feedback_colors))

    def __str__(self):
        # DO NOT change this method.
        return (
            f"({len(self.words)}, {self.difficulty}, "
            f"{color_word(self.feedback_colors, ['â– '] * 5)})"
        )

    def __repr__(self):
        # DO NOT change this method.
        return str(self)


# DO NOT change this function
def print_explanation(attempts):
    """Prints the 'how to play' instructions on the official website"""
    print("Welcome to Command Line Evil Wordle!")
    print()
    print("".join([BOLD_COLOR + letter + NO_COLOR for letter in "How To Play"]))
    print(f"Guess the secret word in {attempts} tries.")
    print("Each guess must be a valid 5-letter word.")
    print("The color of the letters will change to show")
    print("how close your guess was.")
    print()
    print("Examples:")
    print(CORRECT_COLOR + "w" + NO_COLOR, end="")
    print("".join([NOT_IN_WORD_COLOR + letter + NO_COLOR for letter in "eary"]))
    print(BOLD_COLOR + "w" + NO_COLOR, end=" ")
    print("is in the word and in the correct spot.")
    print(NOT_IN_WORD_COLOR + "p" + NO_COLOR, end="")
    print(WRONG_SPOT_COLOR + "i" + NO_COLOR, end="")
    print("".join([NOT_IN_WORD_COLOR + letter + NO_COLOR for letter in "lls"]))
    print(BOLD_COLOR + "i" + NO_COLOR, end=" ")
    print("is in the word but in the wrong spot.")
    print("".join([NOT_IN_WORD_COLOR + letter + NO_COLOR for letter in "vague"]))
    print(BOLD_COLOR + "u" + NO_COLOR, end=" ")
    print("is not in the word in any spot.")
    print()


# DO NOT change this function
def color_word(colors, word):
    """
    Colors a given word using ANSI formatting then returns it as a new string.

    pre: 
        colors: A single ANSI escape code color or list of ANSI escape code colors.
        word: A string containing the character(s) to be formatted.
    post: Returns a string where each character in word is wrapped in the
          corresponding color from colors, followed by NO_COLOR.
    """
    if isinstance(colors, str):
        colors = [colors]
    assert len(colors) == len(word), "The length of colors and word do not match."
    colored_word = [None] * len(word)
    for i, character in enumerate(word):
        colored_word[i] = f"{colors[i]}{character}{NO_COLOR}"
    return "".join(colored_word)


# DO NOT change this function
def get_attempt_label(attempt_number):
    """
    Generates the label for the given attempt number.

    pre: attempt_number is an integer (1 < attempt_number < 100).
    post: returns a string label for a given attempt.
    """
    if 11 <= attempt_number <= 12:
        suffix = "th"
    else:
        suffix = {1: "st", 2: "nd", 3: "rd"}.get(attempt_number % 10, "th")
    return f"{attempt_number}{suffix}"


# DO NOT change this function
def prepare_game():
    """
    Prepares the game by setting the number of attempts and loading the initial 
    pool of valid words through the file, "valid_guesses.txt." The function also 
    handles optional command-line arguments such as a custom number of attempts 
    and a debug flag.

    pre: None
    post: Returns a tuple (attempts, valid_words) or raises a ValueError on invalid user input.
    """
    valid_words_file_name = "valid_guesses.txt"
    if len(sys.argv) > 3:
        raise ValueError()
    if sys.argv[-1] == "debug":
        valid_words_file_name = "test_guesses.txt"
        sys.argv.pop()
    if len(sys.argv) == 1:
        attempts = 6
    elif sys.argv[1].isnumeric():
        attempts = int(sys.argv[1])
        if not 1 < attempts < 100:
            raise ValueError()
    else:
        raise ValueError()
    with open(valid_words_file_name, "r", encoding="ascii") as valid_words:
        valid_words = [word.rstrip() for word in valid_words.readlines()]
    return attempts, valid_words


def fast_sort(lst):
    """
    Returns a new list with the same elements as lst sorted in ascending order using merge sort.
    You may not use built-in sort functions.

    pre: lst is a list.
    post: Returns a new sorted list.
    """
    if len(lst) <= 1:
        return lst[:]

    def merge(left, right):
        result = []
        i, j = 0, 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        result.extend(left[i:])
        result.extend(right[j:])
        return result

    mid = len(lst) // 2
    left = fast_sort(lst[:mid])
    right = fast_sort(lst[mid:])
    return merge(left, right)


def get_feedback_colors(secret_word, guessed_word):
    """
    Processes the guess and generates the colored feedback based on the potential secret word.
    Returns a list of colors indicating for each letter whether it is correct, wrong spot, or not in the word.
    
    pre: secret_word and guessed_word are strings of exactly 5 lowercase letters.
    post: Returns a list of length 5 with ANSI color codes.
    """
    feedback = [None] * NUM_LETTERS
    secret_list = list(secret_word)
    guessed_list = list(guessed_word)
    for i in range(NUM_LETTERS):
        if guessed_list[i] == secret_list[i]:
            feedback[i] = CORRECT_COLOR
            secret_list[i] = None
    for i in range(NUM_LETTERS):
        if feedback[i] is None:
            if guessed_list[i] in secret_list:
                feedback[i] = WRONG_SPOT_COLOR
                index = secret_list.index(guessed_list[i])
                secret_list[index] = None
            else:
                feedback[i] = NOT_IN_WORD_COLOR
    return feedback


def get_feedback(remaining_secret_words, guessed_word):
    """
    Processes the guess and generates the colored feedback based on the hardest word family.
    Groups words by their feedback pattern, then selects the hardest family by the following criteria:
      1. Largest word family (number of words).
      2. Highest difficulty (sum of color difficulties).
      3. Lexicographical ordering of the feedback pattern.
    Returns a tuple (feedback_colors, new_remaining_secret_words).
    
    pre: remaining_secret_words is a list of words, guessed_word is a 5-letter string.
    post: Returns a tuple (list of feedback colors, list of words from the hardest word family).
    """
    families = {}
    for word in remaining_secret_words:
        pattern = tuple(get_feedback_colors(word, guessed_word))
        if pattern not in families:
            families[pattern] = []
        families[pattern].append(word)
    word_families = []
    for pattern, words in families.items():
        wf = WordFamily(pattern, words)
        word_families.append(wf)
    sorted_families = fast_sort(word_families)
    hardest_family = sorted_families[0]
    return list(hardest_family.feedback_colors), hardest_family.words


# DO NOT change this function.
def main():
    """
    This function is the main loop for the game. It sets up the game and processes guesses.
    """
    try:
        valid = prepare_game()
    except ValueError:
        print(INVALID_INPUT)
        return

    attempts, valid_guesses = valid
    secret_words = valid_guesses

    print_explanation(attempts)

    keyboard = Keyboard()
    attempt = 1

    while attempt <= attempts:
        attempt_number_string = get_attempt_label(attempt)
        prompt = f"Enter your {attempt_number_string} guess: "
        guess = input(prompt)
        if not sys.stdin.isatty():
            print(guess)
        if guess not in valid_guesses:
            print(INVALID_INPUT)
            continue

        feedback_colors, secret_words = get_feedback(secret_words, guess)
        feedback = color_word(feedback_colors, guess)
        print(" " * (len(prompt) - 1), feedback)
        keyboard.update(feedback_colors, guess)
        print(keyboard)
        print()

        if len(secret_words) == 1 and guess == secret_words[0]:
            print("Congratulations! ", end="")
            print("You guessed the word '" + feedback + "' correctly.")
            break

        attempt += 1

    if attempt > attempts:
        random.seed(0)
        secret_word = random.choice(fast_sort(secret_words))
        formatted_secret_word = "".join([CORRECT_COLOR + c + NO_COLOR for c in secret_word])
        print("Sorry, you've run out of attempts. The correct word was ", end="")
        print("'" + formatted_secret_word + "'.")


if __name__ == "__main__":
    main()
